//! Contains the [`LogicalStep`] trait for representing a logical step.

pub mod all_naked_singles;
pub mod hidden_single;
pub mod macros;
pub mod naked_single;
pub mod prelude;
pub mod simple_cell_forcing;

use crate::prelude::*;

/// This trait defines the logic of a single logical step.
///
/// For example, this might be a naked single, a hidden single, or a naked pair.
/// Each logical elimination concept has its own implementation of this trait.
/// Generally, these logical steps do not interact with constraints other than
/// through the weak links generated by those constraints.
pub trait LogicalStep {
    /// The name of the logical step for display purposes.
    fn name(&self) -> &'static str;

    /// Returns if this logical step should be active during brute force solves.
    /// This is used to disable logical steps that are not useful during brute force
    /// solves.
    ///
    /// Generally, only the simplest logic is useful during brute force solves, because
    /// guess-and-check is much more efficient than performing complex logic.
    ///
    /// For example, a naked single is useful during brute force solves, but a naked
    /// pair is not.
    ///
    /// The default implementation returns `false` because most logical steps are
    /// not designed to be fast enough for brute force.
    fn is_active_during_brute_force_solves(&self) -> bool {
        false
    }

    /// Returns true if this logical step is active during logical solves.
    /// This is used to disable logical steps during logical solves which do not
    /// or should not report their results in human-readable form.
    ///
    /// The default implementation returns `true` because most logical steps are
    /// designed to be used during logical solves.
    fn is_active_during_logical_solves(&self) -> bool {
        true
    }

    /// Executes one logical step.
    ///
    /// # Arguments
    /// * `board` - The board to execute the step on.
    /// * `desc` - If provided, describe any eliminations as a single appended entry to this list.
    ///
    /// # Return value
    /// Return the following based on the situation:
    /// - [`LogicResult::None`] if the board is unchanged.
    /// - [`LogicResult::Changed`] if the board is changed.
    /// - [`LogicResult::Invalid`] if this constraint has made the solve impossible.
    fn step(&self, board: &mut Board, desc: Option<&mut LogicalStepDescList>) -> LogicResult;
}
