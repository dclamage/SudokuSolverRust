//! Contains the [`LogicalStep`] trait for representing a logical step.

pub mod all_naked_singles;
pub mod hidden_single;
pub mod logical_step_desc;
pub mod logical_step_desc_list;
pub mod logical_step_result;
pub mod naked_single;
pub mod prelude;
pub mod simple_cell_forcing;
pub mod step_constraints;

use crate::prelude::*;

/// This trait defines the logic of a single logical step.
///
/// For example, this might be a naked single, a hidden single, or a naked pair.
/// Each logical elimination concept has its own implementation of this trait.
/// Generally, these logical steps do not interact with constraints other than
/// through the weak links generated by those constraints.
pub trait LogicalStep: std::any::Any + std::fmt::Debug {
    /// The name of the logical step for display purposes.
    fn name(&self) -> &'static str;

    /// Returns if this logical step should be active during brute force solves.
    /// This is used to disable logical steps that are not useful during brute force
    /// solves.
    ///
    /// Generally, only the simplest logic is useful during brute force solves, because
    /// guess-and-check is much more efficient than performing complex logic.
    ///
    /// For example, a naked single is useful during brute force solves, but a naked
    /// pair is not.
    ///
    /// The default implementation returns `false` because most logical steps are
    /// not designed to be fast enough for brute force.
    fn is_active_during_brute_force_solves(&self) -> bool {
        false
    }

    /// Returns true if this logical step is active during logical solves.
    /// This is used to disable logical steps during logical solves which do not
    /// or should not report their results in human-readable form.
    ///
    /// The default implementation returns `true` because most logical steps are
    /// designed to be used during logical solves.
    fn is_active_during_logical_solves(&self) -> bool {
        true
    }

    /// Returns whether this logical step applies its own prefix to the description.
    ///
    /// The default implementation returns `false` because most logical steps do not
    /// apply their own prefix to the description, and instead rely on the prefix
    /// being applied by the caller.
    ///
    /// [`LogicalStepResult::with_prefix`] is useful for applying a prefix to the
    /// description of a logical step result.
    fn has_own_prefix(&self) -> bool {
        false
    }

    /// Runs one logical step on the board.
    ///
    /// # Return value
    /// Return the following based on the situation:
    /// - [`LogicalStepResult::None`] if the board is unchanged.
    /// - [`LogicalStepResult::Changed`] if the board is changed.
    /// - [`LogicalStepResult::Invalid`] if this constraint has made the solve impossible.
    fn run(&self, board: &mut Board, generate_description: bool) -> LogicalStepResult;
}
